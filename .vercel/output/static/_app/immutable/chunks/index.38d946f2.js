import{Q as T,M as j}from"./index.5c1212a0.js";var ht=class{constructor(t,e){this.facenames=t,this.prefixFree=!0,this.gripnames=[],e&&(this.gripnames=e);for(let s=0;this.prefixFree&&s<t.length;s++)for(let i=0;this.prefixFree&&i<t.length;i++)s!==i&&t[s].startsWith(t[i])&&(this.prefixFree=!1)}setGripNames(t){this.gripnames=t}splitByFaceNames(t){const e=[];let s=0;for(;s<t.length;){s>0&&s<t.length&&t[s]==="_"&&s++;let i=-1;for(let n=0;n<this.facenames.length;n++)t.substr(s).startsWith(this.facenames[n])&&(i<0||this.facenames[n].length>this.facenames[i].length)&&(i=n);if(i>=0)e.push(i),s+=this.facenames[i].length;else throw new Error("Could not split "+t+" into face names.")}return e}joinByFaceIndices(t){let e="";const s=[];for(let i=0;i<t.length;i++)s.push(e),s.push(this.facenames[t[i]]),this.prefixFree||(e="_");return s.join("")}spinmatch(t,e){if(t===e)return!0;try{const s=this.splitByFaceNames(t),i=this.splitByFaceNames(e);if(s.length!==i.length&&s.length<3)return!1;for(let n=0;n<s.length;n++){for(let r=0;r<n;r++)if(s[n]===s[r])return!1;let o=!1;for(let r=0;r<i.length;r++)if(s[n]===i[r]){o=!0;break}if(!o)return!1}return!0}catch{return!1}}spinmatchv(t,e){return t.endsWith("v")&&e.endsWith("v")?this.spinmatch(t.slice(0,t.length-1),e.slice(0,e.length-1)):this.spinmatch(t,e)}unswizzle(t){(t.endsWith("v")||t.endsWith("w"))&&t[0]<="Z"&&(t=t.slice(0,t.length-1));const e=t.toUpperCase();for(let s=0;s<this.gripnames.length;s++){const i=this.gripnames[s];if(this.spinmatch(e,i))return i}return t}},Ot=class{notationToInternal(t){return t}notationToExternal(t){return t}},$t=class{constructor(t,e){this.child=t,this.sw=e}notationToInternal(t){return t.family==="T"&&t.innerLayer===void 0&&t.outerLayer===void 0?new j(new T("FLRv",t.innerLayer,t.outerLayer),t.amount):this.child.notationToInternal(t)}notationToExternal(t){let e=t.family;return e.length>0&&e[e.length-1]==="v"&&(e=e.substring(0,e.length-1)),this.sw.spinmatch(e,"FLUR")?new j(new T("T",t.innerLayer,t.outerLayer),t.amount):this.child.notationToExternal(t)}},zt=class{constructor(t,e){this.internalNames=t,this.externalNames=e}convertString(t,e,s){let i="";(t.endsWith("v")||t.endsWith("v"))&&t<="_"&&(i=t.slice(t.length-1),t=t.slice(0,t.length-1));const n=t.toUpperCase();let o=!1;return t!==n&&(o=!0,t=n),t=s.joinByFaceIndices(e.splitByFaceNames(t)),o&&(t=t.toLowerCase()),t+i}convert(t,e,s){const i=t.family,n=this.convertString(i,e,s);return i===n?t:new j(new T(n,t.innerLayer,t.outerLayer),t.amount)}notationToInternal(t){return this.convert(t,this.externalNames,this.internalNames)}notationToExternal(t){return this.convert(t,this.internalNames,this.externalNames)}},Kt=class{constructor(t){this.child=t}notationToInternal(t){if(t.innerLayer===void 0&&t.outerLayer===void 0){if(Math.abs(t.amount)===1){if(t.family==="R++")return new j(new T("L",3,2),-2*t.amount);if(t.family==="R--")return new j(new T("L",3,2),2*t.amount);if(t.family==="D++")return new j(new T("U",3,2),-2*t.amount);if(t.family==="D--")return new j(new T("U",3,2),2*t.amount);if(t.family==="R_PLUSPLUS_")return new j(new T("L",3,2),-2*t.amount);if(t.family==="D_PLUSPLUS_")return new j(new T("U",3,2),-2*t.amount)}if(t.family==="y")return new j("Uv",t.amount)}return this.child.notationToInternal(t)}notationToExternal(t){return t.family==="Uv"?new j(new T("y",t.innerLayer,t.outerLayer),t.amount):t.family==="Dv"?new j("y",-t.amount):this.child.notationToExternal(t)}},Qt=class{constructor(t){this.slices=t}notationToInternal(t){const e=t.family;return!t.innerLayer&&!t.outerLayer&&(e==="x"?t=new j("Rv",t.amount):e==="y"?t=new j("Uv",t.amount):e==="z"&&(t=new j("Fv",t.amount)),(this.slices&1)===1&&(e==="E"?t=new j(new T("D",(this.slices+1)/2),t.amount):e==="M"?t=new j(new T("L",(this.slices+1)/2),t.amount):e==="S"&&(t=new j(new T("F",(this.slices+1)/2),t.amount))),this.slices>2&&(e==="e"?t=new j(new T("D",this.slices-1,2),t.amount):e==="m"?t=new j(new T("L",this.slices-1,2),t.amount):e==="s"&&(t=new j(new T("F",this.slices-1,2),t.amount)))),t}notationToExternal(t){const e=t.family;if(!t.innerLayer&&!t.outerLayer){if(e==="Rv")return new j("x",t.amount);if(e==="Uv")return new j("y",t.amount);if(e==="Fv")return new j("z",t.amount);if(e==="Lv")return new j("x",-t.amount);if(e==="Dv")return new j("y",-t.amount);if(e==="Bv")return new j("z",-t.amount)}return t}},Wt={U:"frl",L:"fld",R:"fdr",B:"dlr",u:"FRL",l:"FLD",r:"FDR",b:"DLR",Uv:"FRLv",Lv:"FLDv",Rv:"FDRv",Bv:"DLRv",D:"D",F:"F",BL:"L",BR:"R"},_t={U:"FRL",L:"FLD",R:"FDR",B:"DLR",u:"frl",l:"fld",r:"fdr",b:"dlr",Uv:"FRLv",Lv:"FLDv",Rv:"FDRv",Bv:"DLRv",D:"D",F:"F",BL:"L",BR:"R",d:"d",f:"f",bl:"l",br:"r"},Mt={U:"FRL",L:"FLD",R:"FDR",B:"DLR"},kt=new T("y"),Ft=new T("Dv"),Pt=class{constructor(t){this.child=t,this.wcaHack=!1,this.map=Wt}notationToInternal(t){if(this.wcaHack&&t.innerLayer===2&&t.outerLayer===null){const s=Mt[t.family];if(s)return new j(new T(s,t.innerLayer,t.outerLayer),t.amount)}const e=this.map[t.family];return e?new j(new T(e,t.innerLayer,t.outerLayer),t.amount):kt.isIdentical(t.quantum)?new j(Ft,-t.amount):null}notationToExternal(t){if(this.wcaHack&&t.innerLayer===2&&t.outerLayer===null){for(const[e,s]of Object.entries(Mt))if(this.child.spinmatch(t.family,s))return new j(new T(e,t.innerLayer,t.outerLayer),t.amount)}for(const[e,s]of Object.entries(this.map))if(this.child.spinmatch(t.family,s))return new j(new T(e,t.innerLayer,t.outerLayer),t.amount);return Ft.isIdentical(t.quantum)?new j(kt,-t.amount):null}},Zt=class extends Pt{constructor(t){super(t),this.map=_t}},Lt={U:"UBL",UL:"ULF",F:"UFR",UR:"URB",B:"DBL",D:"DFR",L:"DLF",R:"DRB",Uv:"UBLv",ULv:"ULFv",Fv:"UFRv",URv:"URBv",Bv:"DBLv",Dv:"DFRv",Lv:"DLFv",Rv:"DRBv"},ct=new T("x"),jt=new T("Rv"),Ht=new T("Lv"),ft=new T("y"),Rt=new T("Uv"),Jt=new T("Dv"),ut=new T("z"),Dt=new T("Fv"),Vt=new T("Bv"),Yt=class{constructor(t){this.child=t}notationToInternal(t){if(t.innerLayer||t.outerLayer)return null;const e=Lt[t.family];return e?new j(new T(e,t.outerLayer,t.innerLayer),t.amount):ct.isIdentical(t.quantum)?new j(jt,t.amount):ft.isIdentical(t.quantum)?new j(Rt,t.amount):ut.isIdentical(t.quantum)?new j(Dt,t.amount):null}notationToExternal(t){for(const[e,s]of Object.entries(Lt))if(this.child.spinmatchv(t.family,s))return new j(new T(e,t.innerLayer,t.outerLayer),t.amount);return jt.isIdentical(t.quantum)?new j(ct,t.amount):Ht.isIdentical(t.quantum)?new j(ct,-t.amount):Rt.isIdentical(t.quantum)?new j(ft,t.amount):Jt.isIdentical(t.quantum)?new j(ft,-t.amount):Dt.isIdentical(t.quantum)?new j(ut,t.amount):Vt.isIdentical(t.quantum)?new j(ut,-t.amount):null}};function ke(t){let e=0;const s={};for(;e<t.length&&t[e][0]==="-";){const n=t[e++];if(n==="--rotations")s.addRotations=!0;else if(n==="--allmoves")s.allMoves=!0;else if(n==="--outerblockmoves")s.outerBlockMoves=!0;else if(n==="--vertexmoves")s.vertexMoves=!0;else if(n==="--nocorners")s.includeCornerOrbits=!1;else if(n==="--noedges")s.includeEdgeOrbits=!1;else if(n==="--noorientation")s.fixedOrientation=!0;else if(n==="--nocenters")s.includeCenterOrbits=!1;else if(n==="--omit")s.excludeOrbits=t[e].split(","),e++;else if(n==="--moves")s.moveList=t[e].split(","),e++;else if(n==="--optimize")s.optimizeOrbits=!0;else if(n==="--scramble")s.scrambleAmount=100;else if(n==="--fixcorner")s.fixedPieceType="v";else if(n==="--fixedge")s.fixedPieceType="e";else if(n==="--fixcenter")s.fixedPieceType="f";else if(n==="--orientcenters")s.orientCenters=!0;else if(n==="--puzzleorientation")s.puzzleOrientation=JSON.parse(t[e]),e++;else throw new Error("Bad option: "+n)}return{puzzleDescription:Ut(t.slice(e).join(" ")),options:s}}var Xt=class{constructor(t={}){this.verbosity=0,this.allMoves=!1,this.vertexMoves=!1,this.addRotations=!1,this.moveList=null,this.fixedOrientation=!1,this.fixedPieceType=null,this.orientCenters=!1,this.includeCornerOrbits=!0,this.includeCenterOrbits=!0,this.includeEdgeOrbits=!0,this.excludeOrbits=[],this.optimizeOrbits=!1,this.grayCorners=!1,this.grayCenters=!1,this.grayEdges=!1,this.puzzleOrientation=null,this.puzzleOrientations=null,this.scrambleAmount=0,Object.assign(this,t)}},pt=[],mt=[];function st(t){if(!pt[t]){const e=Array(t);for(let s=0;s<t;s++)e[s]=0;pt[t]=e}return pt[t]}function Y(t){if(!mt[t]){const e=Array(t);for(let s=0;s<t;s++)e[s]=s;mt[t]=e}return mt[t]}function qt(t){return new X(Y(t))}function te(t){let e=1;for(;t>1;)e*=t,t--;return e}function ee(t,e){if(t>e){const s=t;t=e,e=s}for(;t>0;){const s=e%t;e=t,t=s}return e}function Tt(t,e){return t/ee(t,e)*e}var X=class{constructor(t){this.n=t.length,this.p=t}toString(){return"Perm["+this.p.join(" ")+"]"}mul(t){const e=Array(this.n);for(let s=0;s<this.n;s++)e[s]=t.p[this.p[s]];return new X(e)}rmul(t){const e=Array(this.n);for(let s=0;s<this.n;s++)e[s]=this.p[t.p[s]];return new X(e)}inv(){const t=Array(this.n);for(let e=0;e<this.n;e++)t[this.p[e]]=e;return new X(t)}compareTo(t){for(let e=0;e<this.n;e++)if(this.p[e]!==t.p[e])return this.p[e]-t.p[e];return 0}toGap(){const t=new Array,e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;const i=new Array;for(let n=s;!e[n];n=this.p[n])i.push(1+n),e[n]=!0;t.push("("+i.join(",")+")")}return t.join("")}order(){let t=1;const e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;let i=0;for(let n=s;!e[n];n=this.p[n])i++,e[n]=!0;t=Tt(t,i)}return t}},bt=class{constructor(t,e){this.size=t,this.mod=e}reassemblySize(){return te(this.size)*Math.pow(this.mod,this.size)}},se=0;function Nt(t,e){const s=j.fromString(e),i=t.notationToExternal(s);return i===null||s===i?e:i.toString()}var vt=class{constructor(t,e,s,i,n){this.orbitnames=t,this.orbitdefs=e,this.solved=s,this.movenames=i,this.moveops=n}transformToKTransformationData(t){const e={};for(let s=0;s<this.orbitnames.length;s++)e[this.orbitnames[s]]=t.orbits[s].toKPuzzle();return e}static transformToKTransformationData(t,e){const s={};for(let i=0;i<t.length;i++)s[t[i]]=e.orbits[i].toKPuzzle();return s}toKsolve(t,e=new Ot){const s=[];s.push("Name "+t),s.push("");for(let i=0;i<this.orbitnames.length;i++)s.push(`Set ${this.orbitnames[i]} ${this.orbitdefs[i].size} ${this.orbitdefs[i].mod}`);s.push(""),s.push("Solved");for(let i=0;i<this.orbitnames.length;i++)this.solved.orbits[i].appendDefinition(s,this.orbitnames[i],!1,!1);s.push("End");for(let i=0;i<this.movenames.length;i++){s.push("");let n=Nt(e,this.movenames[i]),o=!1;n[n.length-1]==="'"&&(o=!0,n=n.substring(0,n.length-1)),s.push("Move "+n);for(let r=0;r<this.orbitnames.length;r++)o?this.moveops[i].orbits[r].inv().appendDefinition(s,this.orbitnames[r],!0):this.moveops[i].orbits[r].appendDefinition(s,this.orbitnames[r],!0);s.push("End")}return s}toKPuzzleDefinition(t){const e={},s={};for(let n=0;n<this.orbitnames.length;n++){e[this.orbitnames[n]]={numPieces:this.orbitdefs[n].size,numOrientations:this.orbitdefs[n].mod};const o=this.solved.orbits[n].toKPuzzle();s[this.orbitnames[n]]={pieces:o.permutation,orientation:o.orientation}}const i={};if(t)for(let n=0;n<this.movenames.length;n++)i[this.movenames[n]]=this.transformToKTransformationData(this.moveops[n]);return{name:`PG3D #${++se}`,orbits:e,startStateData:s,moves:i}}optimize(){const t=[],e=[],s=[],i=[];for(let n=0;n<this.moveops.length;n++)i.push([]);for(let n=0;n<this.orbitdefs.length;n++){const o=this.orbitdefs[n].mod,r=this.orbitdefs[n].size,g=new Bt(r),l=new Array(this.orbitdefs[n].size);for(let m=0;m<r;m++)l[m]=!1;for(let m=0;m<this.moveops.length;m++)for(let u=0;u<r;u++)(this.moveops[m].orbits[n].perm[u]!==u||this.moveops[m].orbits[n].ori[u]!==0)&&(l[u]=!0,g.union(u,this.moveops[m].orbits[n].perm[u]));let f=!0;if(o>1){f=!1;const m=new Bt(this.orbitdefs[n].size*o);for(let u=0;u<this.moveops.length;u++)for(let h=0;h<r;h++)if(this.moveops[u].orbits[n].perm[h]!==h||this.moveops[u].orbits[n].ori[h]!==0)for(let d=0;d<o;d++)m.union(h*o+d,this.moveops[u].orbits[n].perm[h]*o+(d+this.moveops[u].orbits[n].ori[h])%o);for(let u=0;!f&&u<r;u++)for(let h=1;h<o;h++)m.find(u*o)===m.find(u*o+h)&&(f=!0);for(let u=0;!f&&u<r;u++)for(let h=0;h<u;h++)this.solved.orbits[n].perm[u]===this.solved.orbits[n].perm[h]&&(f=!0)}let v=-1,a=!1;for(let m=0;m<this.orbitdefs[n].size;m++)if(l[m]){const u=g.find(m);v<0?v=u:v!==u&&(a=!0)}for(let m=0;m<this.orbitdefs[n].size;m++){if(!l[m]||g.find(m)!==m)continue;const h=[],d=[];let w=0;for(let z=0;z<this.orbitdefs[n].size;z++)g.find(z)===m&&(h[w]=z,d[z]=w,w++);if(a?t.push(`${this.orbitnames[n]}_p${m}`):t.push(this.orbitnames[n]),f){e.push(new bt(w,this.orbitdefs[n].mod)),s.push(this.solved.orbits[n].remapVS(h,w));for(let z=0;z<this.moveops.length;z++)i[z].push(this.moveops[z].orbits[n].remap(h,d,w))}else{e.push(new bt(w,1)),s.push(this.solved.orbits[n].remapVS(h,w).killOri());for(let z=0;z<this.moveops.length;z++)i[z].push(this.moveops[z].orbits[n].remap(h,d,w).killOri())}}}return new vt(t,e,new yt(s),this.movenames,i.map(n=>new nt(n)))}scramble(t){this.solved=this.solved.mul(this.getScrambleTransformation(t))}getScrambleTransformation(t){t<100&&(t=100);const e=[];for(let i=0;i<this.moveops.length;i++)e[i]=this.moveops[i];for(let i=0;i<e.length;i++){const n=Math.floor(Math.random()*e.length),o=e[i];e[i]=e[n],e[n]=o}t<e.length&&(t=e.length);for(let i=0;i<t;i++){const n=Math.floor(Math.random()*e.length),o=Math.floor(Math.random()*e.length),r=Math.floor(Math.random()*this.moveops.length);e[n]=e[n].mul(e[o]).mul(this.moveops[r]),Math.random()<.1&&(e[n]=e[n].mul(this.moveops[r]))}let s=e[0];for(let i=1;i<e.length;i++)s=s.mul(e[i]);return s}reassemblySize(){let t=1;for(let e=0;e<this.orbitdefs.length;e++)t*=this.orbitdefs[e].reassemblySize();return t}},J=class{constructor(t,e,s){this.perm=t,this.ori=e,this.orimod=s}static e(t,e){return new J(Y(t),st(t),e)}mul(t){const e=this.perm.length,s=new Array(e);if(this.orimod===1){for(let i=0;i<e;i++)s[i]=this.perm[t.perm[i]];return new J(s,this.ori,this.orimod)}else{const i=new Array(e);for(let n=0;n<e;n++)s[n]=this.perm[t.perm[n]],i[n]=(this.ori[t.perm[n]]+t.ori[n])%this.orimod;return new J(s,i,this.orimod)}}inv(){const t=this.perm.length,e=new Array(t),s=new Array(t);for(let i=0;i<t;i++)e[this.perm[i]]=i,s[this.perm[i]]=(this.orimod-this.ori[i])%this.orimod;return new J(e,s,this.orimod)}equal(t){const e=this.perm.length;for(let s=0;s<e;s++)if(this.perm[s]!==t.perm[s]||this.ori[s]!==t.ori[s])return!1;return!0}killOri(){const t=this.perm.length;for(let e=0;e<t;e++)this.ori[e]=0;return this.orimod=1,this}toPerm(){const t=this.orimod;if(t===1)return new X(this.perm);const e=this.perm.length,s=new Array(e*t);for(let i=0;i<e;i++)for(let n=0;n<t;n++)s[i*t+n]=t*this.perm[i]+(this.ori[i]+n)%t;return new X(s)}identicalPieces(){const t=[],e=this.perm.length,s=[];for(let i=0;i<e;i++){const n=this.perm[i];if(t[n]===void 0){const o=[i];t[n]=!0;for(let r=i+1;r<e;r++)this.perm[r]===n&&o.push(r);s.push(o)}}return s}order(){return this.toPerm().order()}isIdentity(){const t=this.perm.length;if(this.perm===Y(t)&&this.ori===st(t))return!0;for(let e=0;e<t;e++)if(this.perm[e]!==e||this.ori[e]!==0)return!1;return!0}zeroOris(){const t=this.perm.length;if(this.ori===st(t))return!0;for(let e=0;e<t;e++)if(this.ori[e]!==0)return!1;return!0}remap(t,e,s){const i=new Array(s),n=new Array(s);for(let o=0;o<s;o++)i[o]=e[this.perm[t[o]]],n[o]=this.ori[t[o]];return new J(i,n,this.orimod)}remapVS(t,e){const s=new Array(e),i=new Array(e);let n=0;const o=[];for(let r=0;r<e;r++){const g=this.perm[t[r]];o[g]===void 0&&(o[g]=n++),s[r]=o[g],i[r]=this.ori[t[r]]}return new J(s,i,this.orimod)}appendDefinition(t,e,s,i=!0){if(!(i&&this.isIdentity())&&(t.push(e),t.push(this.perm.map(n=>n+1).join(" ")),!this.zeroOris()))if(s){const n=new Array(this.ori.length);for(let o=0;o<n.length;o++)n[this.perm[o]]=this.ori[o];t.push(n.join(" "))}else t.push(this.ori.join(" "))}toKPuzzle(){const t=this.perm.length;return this.isIdentity()?(J.kcache[t]||(J.kcache[t]={permutation:Y(t),orientation:st(t)}),J.kcache[t]):{permutation:this.perm,orientation:this.ori}}},et=J;et.kcache=[];var St=class{constructor(t){this.orbits=t}internalMul(t){const e=[];for(let s=0;s<this.orbits.length;s++)e.push(this.orbits[s].mul(t.orbits[s]));return e}internalInv(){const t=[];for(const e of this.orbits)t.push(e.inv());return t}equal(t){for(let e=0;e<this.orbits.length;e++)if(!this.orbits[e].equal(t.orbits[e]))return!1;return!0}killOri(){for(const t of this.orbits)t.killOri();return this}toPerm(){const t=new Array;let e=0;for(const i of this.orbits){const n=i.toPerm();t.push(n),e+=n.n}const s=new Array(e);e=0;for(const i of t){for(let n=0;n<i.n;n++)s[e+n]=e+i.p[n];e+=i.n}return new X(s)}identicalPieces(){const t=[];let e=0;for(const s of this.orbits){const i=s.orimod,n=s.identicalPieces();for(let o=0;o<n.length;o++)t.push(n[o].map(r=>r*i+e));e+=i*s.perm.length}return t}order(){let t=1;for(const e of this.orbits)t=Tt(t,e.order());return t}},nt=class extends St{constructor(t){super(t)}mul(t){return new nt(this.internalMul(t))}mulScalar(t){if(t===0)return this.e();let e=this;for(t<0&&(e=e.inv(),t=-t);!(t&1);)e=e.mul(e),t>>=1;if(t===1)return e;let s=e,i=this.e();for(;t>0;)t&1&&(i=i.mul(s)),t>1&&(s=s.mul(s)),t>>=1;return i}inv(){return new nt(this.internalInv())}e(){return new nt(this.orbits.map(t=>et.e(t.perm.length,t.orimod)))}},yt=class extends St{constructor(t){super(t)}mul(t){return new yt(this.internalMul(t))}},Bt=class{constructor(t){this.n=t,this.heads=new Array(t);for(let e=0;e<t;e++)this.heads[e]=e}find(t){let e=this.heads[t];return this.heads[e]===e||(e=this.find(this.heads[e]),this.heads[t]=e),e}union(t,e){const s=this.find(t),i=this.find(e);s<i?this.heads[i]=s:s>i&&(this.heads[s]=i)}};function ie(t,e){const s=t.moveops.length;if(s>30)throw new Error("Canon info too big for bitmask");const i=[],n=[];for(let r=0;r<s;r++){const g=t.moveops[r];i.push(g.order());let l=0;for(let f=0;f<s;f++){if(f===r)continue;const v=t.moveops[f];g.mul(v).equal(v.mul(g))&&(l|=1<<f)}n.push(l)}let o={};o[0]=1;for(let r=0;r<100;r++){let g=0;const l={};let f=0;for(const v in o){const a=+v,m=o[a];g+=m,f++;for(let u=0;u<i.length;u++)if(!(a>>u&1)&&!(a&n[u]&(1<<u)-1)){const h=a&n[u]|1<<u;l[h]===void 0&&(l[h]=0),l[h]+=(i[u]-1)*m}}e(`${r}: canonseq ${g} states ${f}`),o=l}}var xt={"2x2x2":"c f 0","3x3x3":"c f 0.333333333333333","4x4x4":"c f 0.5 f 0","5x5x5":"c f 0.6 f 0.2","6x6x6":"c f 0.666666666666667 f 0.333333333333333 f 0","7x7x7":"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143","8x8x8":"c f 0.75 f 0.5 f 0.25 f 0","9x9x9":"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111","10x10x10":"c f 0.8 f 0.6 f 0.4 f 0.2 f 0","11x11x11":"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909","12x12x12":"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0","13x13x13":"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769","20x20x20":"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9","30x30x30":"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333","40x40x40":"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95",skewb:"c v 0","master skewb":"c v 0.275","professor skewb":"c v 0 v 0.38","compy cube":"c v 0.915641442663986",helicopter:"c e 0.707106781186547","curvy copter":"c e 0.83",dino:"c v 0.577350269189626","little chop":"c e 0",pyramorphix:"t e 0",mastermorphix:"t e 0.346184634065199",pyraminx:"t v 0.333333333333333 v 1.66666666666667",tetraminx:"t v 0.333333333333333","master pyraminx":"t v 0 v 1 v 2","master tetraminx":"t v 0 v 1","professor pyraminx":"t v -0.2 v 0.6 v 1.4 v 2.2","professor tetraminx":"t v -0.2 v 0.6 v 1.4","Jing pyraminx":"t f 0","master pyramorphix":"t e 0.866025403784437",megaminx:"d f 0.7",gigaminx:"d f 0.64 f 0.82",teraminx:"d f 0.64 f 0.76 f 0.88",petaminx:"d f 0.64 f 0.73 f 0.82 f 0.91",examinx:"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928",zetaminx:"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94",yottaminx:"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486",pentultimate:"d f 0","master pentultimate":"d f 0.1","elite pentultimate":"d f 0 f 0.145905",starminx:"d v 0.937962370425399","starminx 2":"d f 0.23606797749979","pyraminx crystal":"d f 0.447213595499989",chopasaurus:"d v 0","big chop":"d e 0","skewb diamond":"o f 0",FTO:"o f 0.333333333333333","master FTO":"o f 0.5 f 0","Christopher's jewel":"o v 0.577350269189626",octastar:"o e 0","Trajber's octahedron":"o v 0.433012701892219","radio chop":"i f 0",icosamate:"i v 0","icosahedron 2":"i v 0.18759247376021","icosahedron 3":"i v 0.18759247376021 e 0","icosahedron static faces":"i v 0.84","icosahedron moving faces":"i v 0.73","Eitan's star":"i f 0.61803398874989","2x2x2 + dino":"c f 0 v 0.577350269189626","2x2x2 + little chop":"c f 0 e 0","dino + little chop":"c v 0.577350269189626 e 0","2x2x2 + dino + little chop":"c f 0 v 0.577350269189626 e 0","megaminx + chopasaurus":"d f 0.61803398875 v 0","starminx combo":"d f 0.23606797749979 v 0.937962370425399"},tt=1e-9;function dt(t){let e=new C(0,0,0,0);for(let s=0;s<t.length;s++)e=e.sum(t[s]);return e.smul(1/t.length)}function ne(t,e,s,i){const n=i[t].intersect3(i[e],i[s]);if(!n)return n;for(let o=0;o<i.length;o++)if(o!==t&&o!==e&&o!==s){const r=i[o].b*n.b+i[o].c*n.c+i[o].d*n.d;if(i[o].a>0&&r>i[o].a||i[o].a<0&&r<i[o].a)return!1}return n}var C=class{constructor(t,e,s,i){this.a=t,this.b=e,this.c=s,this.d=i}mul(t){return new C(this.a*t.a-this.b*t.b-this.c*t.c-this.d*t.d,this.a*t.b+this.b*t.a+this.c*t.d-this.d*t.c,this.a*t.c-this.b*t.d+this.c*t.a+this.d*t.b,this.a*t.d+this.b*t.c-this.c*t.b+this.d*t.a)}toString(){return`Q[${this.a},${this.b},${this.c},${this.d}]`}dist(t){return Math.hypot(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}len(){return Math.hypot(this.a,this.b,this.c,this.d)}cross(t){return new C(0,this.c*t.d-this.d*t.c,this.d*t.b-this.b*t.d,this.b*t.c-this.c*t.b)}dot(t){return this.b*t.b+this.c*t.c+this.d*t.d}normalize(){const t=Math.sqrt(this.dot(this));return new C(this.a/t,this.b/t,this.c/t,this.d/t)}makenormal(){return new C(0,this.b,this.c,this.d).normalize()}normalizeplane(){const t=Math.hypot(this.b,this.c,this.d);return new C(this.a/t,this.b/t,this.c/t,this.d/t)}smul(t){return new C(this.a*t,this.b*t,this.c*t,this.d*t)}sum(t){return new C(this.a+t.a,this.b+t.b,this.c+t.c,this.d+t.d)}sub(t){return new C(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}angle(){return 2*Math.acos(this.a)}invrot(){return new C(this.a,-this.b,-this.c,-this.d)}det3x3(t,e,s,i,n,o,r,g,l){return t*(n*l-o*g)+e*(o*r-i*l)+s*(i*g-n*r)}rotateplane(t){const e=t.mul(new C(0,this.b,this.c,this.d)).mul(t.invrot());return e.a=this.a,e}orthogonal(){const t=Math.abs(this.b),e=Math.abs(this.c),s=Math.abs(this.d);return t<e&&t<s?this.cross(new C(0,1,0,0)).normalize():e<t&&e<s?this.cross(new C(0,0,1,0)).normalize():this.cross(new C(0,0,0,1)).normalize()}pointrotation(t){const e=this.normalize();if(t=t.normalize(),e.sub(t).len()<tt)return new C(1,0,0,0);let s=e.sum(t);s.len()<tt?s=s.orthogonal():s=s.normalize();const i=e.cross(s);return i.a=e.dot(s),i}unproject(t){return this.sum(t.smul(-this.dot(t)/(this.len()*t.len())))}rotatepoint(t){return t.mul(this).mul(t.invrot())}rotateface(t){return t.map(e=>e.rotatepoint(this))}intersect3(t,e){const s=this.det3x3(this.b,this.c,this.d,t.b,t.c,t.d,e.b,e.c,e.d);return Math.abs(s)<tt?!1:new C(0,this.det3x3(this.a,this.c,this.d,t.a,t.c,t.d,e.a,e.c,e.d)/s,this.det3x3(this.b,this.a,this.d,t.b,t.a,t.d,e.b,e.a,e.d)/s,this.det3x3(this.b,this.c,this.a,t.b,t.c,t.a,e.b,e.c,e.a)/s)}side(t){return t>tt?1:t<-tt?-1:0}cutface(t){const e=this.a;let s=0,i=null;for(let n=0;n<t.length;n++)s|=1<<this.side(t[n].dot(this)-e)+1;if((s&5)===5){i=[];const n=t.map(o=>this.side(o.dot(this)-e));for(let o=-1;o<=1;o+=2){const r=[];for(let g=0;g<t.length;g++){(n[g]===o||n[g]===0)&&r.push(t[g]);const l=(g+1)%t.length;if(n[g]+n[l]===0&&n[g]!==0){const f=t[g].dot(this)-e,v=t[l].dot(this)-e,a=f/(f-v),m=t[g].smul(1-a).sum(t[l].smul(a));r.push(m)}}i.push(r)}}return i}cutfaces(t){const e=[];for(let s=0;s<t.length;s++){const i=t[s],n=this.cutface(i);n?(e.push(n[0]),e.push(n[1])):e.push(i)}return e}faceside(t){const e=this.a;for(let s=0;s<t.length;s++){const i=this.side(t[s].dot(this)-e);if(i!==0)return i}throw new Error("Could not determine side of plane in faceside")}sameplane(t){const e=this.normalize(),s=t.normalize();return e.dist(s)<tt||e.dist(s.smul(-1))<tt}makecut(t){return new C(t,this.b,this.c,this.d)}},at=1e-9;function oe(){const t=Math.sqrt(.5);return[new C(t,t,0,0),new C(t,0,t,0)]}function re(){return[new C(.5,.5,.5,.5),new C(.5,.5,.5,-.5)]}function ae(){const t=2*Math.PI/10;let e=.5+.3*Math.sqrt(5),s=.5+.1*Math.sqrt(5);const i=Math.sqrt(e*e+s*s);return e/=i,s/=i,[new C(Math.cos(t),e*Math.sin(t),s*Math.sin(t),0),new C(.5,.5,.5,.5)]}function le(){let t=.16666666666666666+Math.sqrt(5)/6,e=2/3+Math.sqrt(5)/3;const s=Math.sqrt(t*t+e*e);t/=s,e/=s;const i=2*Math.PI/6;return[new C(Math.cos(i),t*Math.sin(i),e*Math.sin(i),0),new C(Math.cos(i),-t*Math.sin(i),e*Math.sin(i),0)]}function he(){const t=Math.sqrt(.5);return[new C(.5,.5,.5,.5),new C(t,0,0,t)]}function ce(t){const e=[new C(1,0,0,0)];for(let s=0;s<e.length;s++)for(let i=0;i<t.length;i++){const n=t[i].mul(e[s]),o=n.smul(-1);let r=!1;for(let g=0;g<e.length;g++)if(n.dist(e[g])<at||o.dist(e[g])<at){r=!0;break}r||e.push(n)}return e}function Ct(t,e){const s=[],i=[];for(let n=0;n<e.length;n++){const o=t.rotateplane(e[n]);let r=!1;for(let g=0;g<s.length;g++)if(o.dist(s[g])<at){r=!0;break}r||(s.push(o),i.push(e[n]))}return i}function Et(t){const e=[];for(let s=1;s<t.length;s++)for(let i=s+1;i<t.length;i++){const n=ne(0,s,i,t);if(n){let o=!1;for(let r=0;r<e.length;r++)if(n.dist(e[r])<at){o=!0;break}o||e.push(n)}}for(;;){let s=!1;for(let i=0;i<e.length;i++){const n=(i+1)%e.length;if(t[0].dot(e[i].cross(e[n]))<0){const o=e[i];e[i]=e[n],e[n]=o,s=!0}}if(!s)break}return e}var fe=class{constructor(){this.mult=[]}multiply(t){for(let e=2;e*e<=t;e++)for(;t%e===0;)this.mult[e]!==void 0?this.mult[e]++:this.mult[e]=1,t/=e;t>1&&(this.mult[t]!==void 0?this.mult[t]++:this.mult[t]=1)}toString(){let t="";for(let e=0;e<this.mult.length;e++)this.mult[e]!==void 0&&(t!==""&&(t+="*"),t+=e,this.mult[e]>1&&(t+=`^${this.mult[e]}`));return t}};function ue(t,e){const s=t[0].p.length,i=qt(s);let n=[],o=[],r=[],g=[],l=[];function f(u){for(let h=u.p.length-1;h>=0;h--){const d=u.p[h];if(d!==h){if(!n[h][d])return!1;u=u.mul(o[h][d])}}return!0}function v(u,h,d){g[u].push(h),l[u].push(d);for(let w=0;w<n[u].length;w++)n[u][w]&&a(u,n[u][w].mul(h),d+r[u][w])}function a(u,h,d){const w=h.p[u];if(!n[u][w]){n[u][w]=h,o[u][w]=h.inv(),r[u][w]=d;for(let x=0;x<g[u].length;x++)a(u,h.mul(g[u][x]),d+l[u][x]);return}const z=h.mul(o[u][w]);f(z)||v(u-1,z,d+r[u][w])}function m(){n=[],o=[],g=[],r=[],l=[];for(let d=0;d<s;d++)n.push([]),o.push([]),r.push([]),g.push([]),l.push([]),n[d][d]=i,o[d][d]=i,r[d][d]=0;let u=0,h=1;for(let d=0;d<t.length;d++){v(s-1,t[d],1),h=1;let w=0,z=0;const x=new fe;for(let E=0;E<s;E++){let O=0,G=0;for(let N=0;N<s;N++)n[E][N]&&(O++,G+=r[E][N],E!==N&&u++);w+=g[E].length,h*=O,O>1&&x.multiply(O);const H=G/O;z+=H}e(`${d}: sz ${h} T ${w} sol ${z} none ${u} mults ${x.toString()}`)}return h}return m()}var lt=class{constructor(t){this.coords=new Array(t.length*3);for(let e=0;e<t.length;e++)this.coords[3*e]=t[e].b,this.coords[3*e+1]=t[e].c,this.coords[3*e+2]=t[e].d;this.length=t.length}get(t){return new C(0,this.coords[3*t],this.coords[3*t+1],this.coords[3*t+2])}centermass(){let t=0,e=0,s=0;for(let i=0;i<this.length;i++)t+=this.coords[3*i],e+=this.coords[3*i+1],s+=this.coords[3*i+2];return new C(0,t/this.length,e/this.length,s/this.length)}rotate(t){const e=[];for(let s=0;s<this.length;s++)e.push(this.get(s).rotatepoint(t));return new lt(e)}rotateforward(){const t=[];for(let e=1;e<this.length;e++)t.push(this.get(e));return t.push(this.get(0)),new lt(t)}},wt=class{constructor(t,e,s){this.face=t,this.left=e,this.right=s}split(t){var s,i;const e=t.cutface(this.face);return e!==null&&(this.left===void 0?(this.left=new wt(e[0]),this.right=new wt(e[1])):(this.left=(s=this.left)==null?void 0:s.split(t),this.right=(i=this.right)==null?void 0:i.split(t))),this}collect(t,e){var s,i,n,o;return this.left===void 0?t.push(new lt(this.face)):e?((s=this.left)==null||s.collect(t,!1),(i=this.right)==null||i.collect(t,!0)):((n=this.right)==null||n.collect(t,!1),(o=this.left)==null||o.collect(t,!0)),t}};function pe(t,e){const s=[];for(const i of t)for(const n of e)s.push(n.rotate(i));return s}var A=1e-9,me="PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.";function de(){return{4:[["F","D","L","R"]],6:[["F","D","L","U","R"],["R","F","","B",""]],8:[["F","D","L","R"],["D","F","BR",""],["BR","D","","BB"],["BB","BR","U","BL"]],12:[["U","F","","","",""],["F","U","R","C","A","L"],["R","F","","","E",""],["E","R","","BF","",""],["BF","E","BR","BL","I","D"]],20:[["R","C","F","E"],["F","R","L","U"],["L","F","A",""],["E","R","G","I"],["I","E","S","H"],["S","I","J","B"],["B","S","K","D"],["K","B","M","O"],["O","K","P","N"],["P","O","Q",""]]}}function ge(){return{4:{F:"#00ff00",D:"#ffff00",L:"#ff0000",R:"#0000ff"},6:{U:"#ffffff",F:"#00ff00",R:"#ff0000",D:"#ffff00",B:"#0000ff",L:"#ff8000"},8:{U:"#ffffff",F:"#ff0000",R:"#00bb00",D:"#ffff00",BB:"#1122ff",L:"#9524c5",BL:"#ff8800",BR:"#aaaaaa"},12:{U:"#ffffff",F:"#006633",R:"#ff0000",C:"#ffffd0",A:"#3399ff",L:"#660099",E:"#ff66cc",BF:"#99ff00",BR:"#0000ff",BL:"#ffff00",I:"#ff6633",D:"#999999"},20:{R:"#db69f0",C:"#178fde",F:"#23238b",E:"#9cc726",L:"#2c212d",U:"#177fa7",A:"#e0de7f",G:"#2b57c0",I:"#41126b",S:"#4b8c28",H:"#7c098d",J:"#7fe7b4",B:"#85fb74",K:"#3f4bc3",D:"#0ff555",M:"#f1c2c8",O:"#58d340",P:"#c514f2",N:"#14494e",Q:"#8b1be1"}}}function be(){return{4:["F","D","L","R"],6:["U","D","F","B","L","R"],8:["F","BB","D","U","BR","L","R","BL"],12:["L","E","F","BF","R","I","U","D","BR","A","BL","C"],20:["L","S","E","O","F","B","I","P","R","K","U","D","J","A","Q","H","G","N","M","C"]}}function we(){return{4:[["FLR",[0,1,0]],["F",[0,0,1]]],6:[["U",[0,1,0]],["F",[0,0,1]]],8:[["U",[0,1,0]],["F",[0,0,1]]],12:[["U",[0,1,0]],["F",[0,0,1]]],20:[["GUQMJ",[0,1,0]],["F",[0,0,1]]]}}function ot(t,e){for(let s=0;s<t.length;s++)if(t[s][0].dist(e)<A)return s;throw new Error("Element not found")}function Fe(){return xt}function Le(t){return xt[t]}function Ut(t){const e=t.split(/ /).filter(Boolean);if(e.length%2===0)return null;const s=e[0];if(s!=="o"&&s!=="c"&&s!=="i"&&s!=="d"&&s!=="t")return null;const i=[];for(let n=1;n<e.length;n+=2){if(e[n]!=="f"&&e[n]!=="v"&&e[n]!=="e")return null;i.push({cutType:e[n],distance:parseFloat(e[n+1])})}return{shape:s,cuts:i}}function ve(t,e={}){const s=Ut(t);if(s===null)throw new Error("Could not parse the puzzle description");const i=new ze(s,Object.assign({},{allMoves:!0},e));return i.allstickers(),i.genperms(),i}function je(t,e){return ve(xt[t],e)}function ye(t,e,s){let i=!1;s-e[1]<e[0]&&(t=[t[2],t[3],t[0],t[1]],e=[s-e[1],s-e[0]],i=!0);let n=t[0],o="";if(e[0]===0&&e[1]===s)n=n+"v";else if(e[0]===e[1])e[1]>0&&(o=String(e[1]+1));else if(e[0]===0)n=n.toLowerCase(),e[1]>1&&(o=String(e[1]+1));else throw`We only support slice and outer block moves right now. ${e}`;return[o+n,i]}function xe(t,e){const s=[];let i=0;for(;i<t.length;){i>0&&i<t.length&&t[i]==="_"&&i++;let n="";for(const o of e)t.substr(i).startsWith(o[1])&&o[1].length>n.length&&(n=o[1]);if(n!=="")s.push(n),i+=n.length;else throw new Error("Could not split "+t+" into face names.")}return s}function rt(t,e){return[t.b/e,-t.c/e,t.d/e]}function gt(t,e){const s=[],i=t.length;for(let n=0;n<i;n++){const o=rt(t.get(i-n-1),e);s[3*n]=o[0],s[3*n+1]=o[1],s[3*n+2]=o[2]}return s}var ze=class{constructor(t,e){this.puzzleDescription=t,this.cmovesbyslice=[],this.duplicatedFaces=[],this.duplicatedCubies=[],this.fixedCubie=-1,this.net=[],this.colors=[],this.faceorder=[],this.faceprecedence=[],this.notationMapper=new Ot,this.addNotationMapper="",this.setReidOrder=!1,this.options=new Xt(e),this.options.verbosity>0&&console.log(this.header("# ")),this.create(t)}create(t){const{shape:e,cuts:s}=t;this.moveplanes=[],this.moveplanes2=[],this.faces=[],this.cubies=[];let i=null;switch(e){case"c":i=oe();break;case"o":i=he();break;case"i":i=le();break;case"t":i=re();break;case"d":i=ae();break;default:throw new Error("Bad shape argument: "+e)}this.rotations=ce(i),this.options.verbosity&&console.log("# Rotations: "+this.rotations.length);const n=i[0];this.baseplanerot=Ct(n,this.rotations);const o=this.baseplanerot.map(c=>n.rotateplane(c));this.baseplanes=o,this.baseFaceCount=o.length;const r=de()[o.length];this.net=r,this.colors=ge()[o.length],this.faceorder=be()[o.length],this.options.verbosity>0&&console.log("# Base planes: "+o.length);const g=Et(o),l=new C(0,0,0,0);this.options.verbosity>0&&console.log("# Face vertices: "+g.length);const f=o[0].makenormal(),v=g[0].sum(g[1]).makenormal(),a=g[0].makenormal(),m=new C(1,f.b,f.c,f.d);this.options.verbosity>0&&console.log("# Boundary is "+m);const h=Ct(m,this.rotations).map(c=>m.rotateplane(c)),d=Et(h);this.edgedistance=d[0].sum(d[1]).smul(.5).dist(l),this.vertexdistance=d[0].dist(l);const w=[],z=[];let x=!1,E=!1,O=!1;for(const c of s){let b=null,D=0;switch(c.cutType){case"f":b=f,D=1,x=!0;break;case"v":b=a,D=this.vertexdistance,O=!0;break;case"e":b=v,D=this.edgedistance,E=!0;break;default:throw new Error("Bad cut argument: "+c.cutType)}w.push(b.makecut(c.distance)),z.push(c.distance<D)}this.options.addRotations&&(x||w.push(f.makecut(10)),O||w.push(a.makecut(10)),E||w.push(v.makecut(10))),this.basefaces=[];for(const c of this.baseplanerot){const b=c.rotateface(d);this.basefaces.push(new lt(b))}const G=[],H=[],N=[],p=[],k=d.length;function R(c,b,D){for(const B of c)if(B[0].dist(b)<A){B.push(D);return}c.push([b,D])}for(let c=0;c<this.baseplanerot.length;c++){const b=this.baseplanerot[c].rotateface(d);for(let D=0;D<b.length;D++){const B=(D+1)%b.length,S=b[D].sum(b[B]).smul(.5);R(p,S,c)}}const F=[];for(let c=0;c<this.baseplanerot.length;c++){const b=this.baseplanerot[c].rotateface(d),D=[];for(let B=0;B<b.length;B++){const S=(B+1)%b.length,Q=b[B].sum(b[S]).smul(.5),Z=p[ot(p,Q)];if(c===Z[1])D.push(Z[2]);else if(c===Z[2])D.push(Z[1]);else throw new Error("Could not find edge")}F.push(D)}const M={},y=[];y.push(r[0][0]),M[r[0][0]]=0,y[F[0][0]]=r[0][1],M[r[0][1]]=F[0][0];for(const c of r){const b=c[0],D=M[b];if(D===void 0)throw new Error("Bad edge description; first edge not connected");let B=-1;for(let S=0;S<F[D].length;S++){const Q=y[F[D][S]];if(Q!==void 0&&Q===c[1]){B=S;break}}if(B<0)throw new Error("First element of a net not known");for(let S=2;S<c.length;S++){if(c[S]==="")continue;const Q=F[D][(S+B-1)%k],Z=y[Q];if(Z!==void 0&&Z!==c[S])throw new Error("Face mismatch in net");y[Q]=c[S],M[c[S]]=Q}}for(let c=0;c<y.length;c++){let b=!1;for(let D=0;D<this.faceorder.length;D++)if(y[c]===this.faceorder[D]){this.faceprecedence[c]=D,b=!0;break}if(!b)throw new Error("Could not find face "+y[c]+" in face order list "+this.faceorder)}for(let c=0;c<this.baseplanerot.length;c++){const b=this.baseplanerot[c].rotateface(d),D=m.rotateplane(this.baseplanerot[c]),B=y[c];G.push([b,B]),H.push([D,B])}for(let c=0;c<this.baseplanerot.length;c++){const b=this.baseplanerot[c].rotateface(d),D=y[c];for(let B=0;B<b.length;B++){const S=(B+1)%b.length,Q=b[B].sum(b[S]).smul(.5),Z=(B+2)%b.length,It=b[S].sum(b[Z]).smul(.5),At=ot(p,Q),Gt=ot(p,It);R(N,b[S],[D,Gt,At])}}this.swizzler=new ht(G.map(c=>c[1]));const L=this.swizzler.prefixFree?"":"_";for(let c=0;c<p.length;c++){if(p[c].length!==3)throw new Error("Bad length in edge names "+p[c]);let b=y[p[c][1]];const D=y[p[c][2]];this.faceprecedence[p[c][1]]<this.faceprecedence[p[c][2]]?b=b+L+D:b=D+L+b,p[c]=[p[c][0],b]}for(let c=0;c<N.length;c++){if(N[c].length<4)throw new Error("Bad length in vertex names");let b=1;for(let B=2;B<N[c].length;B++)this.faceprecedence[M[N[c][B][0]]]<this.faceprecedence[M[N[c][b][0]]]&&(b=B);let D="";for(let B=1;B<N[c].length;B++){B===1?D=N[c][b][0]:D=D+L+N[c][b][0];for(let S=1;S<N[c].length;S++)if(N[c][b][1]===N[c][S][2]){b=S;break}}N[c]=[N[c][0],D]}this.options.verbosity>1&&(console.log("# Face precedence list: "+this.faceorder.join(" ")),console.log("# Face names: "+G.map(c=>c[1]).join(" ")),console.log("# Edge names: "+p.map(c=>c[1]).join(" ")),console.log("# Vertex names: "+N.map(c=>c[1]).join(" ")));const P=[];for(const c of H)P.push([c[0].makenormal(),c[1],"f"]);for(const c of p)P.push([c[0].makenormal(),c[1],"e"]);for(const c of N)P.push([c[0].makenormal(),c[1],"v"]);this.facenames=G,this.faceplanes=H,this.edgenames=p,this.vertexnames=N,this.geonormals=P;const U=P.map(c=>c[1]);this.swizzler.setGripNames(U),this.options.verbosity>0&&console.log("# Distances: face "+1+" edge "+this.edgedistance+" vertex "+this.vertexdistance);for(let c=0;c<w.length;c++)for(const b of this.rotations){const D=w[c].rotateplane(b);let B=!1;for(const S of this.moveplanes)if(D.sameplane(S)){B=!0;break}B||(this.moveplanes.push(D),z[c]&&this.moveplanes2.push(D))}let I=new wt(d);const $=this.moveplanes2.slice();let W=31;for(let c=0;c<$.length;c++){const b=c+Math.floor(($.length-c)*(W/65536));I=I.split($[b]),$[b]=$[c],W=(W*1657+101)%65536}const K=I.collect([],!0);this.faces=K,this.options.verbosity>0&&console.log("# Faces is now "+K.length),this.stickersperface=K.length;const V=[],it=dt(d);for(const c of this.rotations){const b=c.rotateface(d);it.dist(dt(b))<A&&V.push(c)}const q=new Array(K.length),_=[];for(let c=0;c<K.length;c++){const b=K[c].centermass();_.push([it.dist(b),b,c])}_.sort((c,b)=>c[0]-b[0]);for(let c=0;c<K.length;c++){const b=_[c][2];if(!q[b]){q[b]=!0;for(const D of V){const B=K[b].rotate(D),S=B.centermass();for(let Q=c+1;Q<K.length&&!(_[Q][0]-_[c][0]>A);Q++){const Z=_[Q][2];if(!q[Z]&&S.dist(_[Q][1])<A){q[Z]=!0,K[Z]=B;break}}}}}this.shortedge=1e99;for(const c of K)for(let b=0;b<c.length;b++){const D=(b+1)%c.length,B=c.get(b).dist(c.get(D));B<this.shortedge&&(this.shortedge=B)}this.options.verbosity>0&&console.log("# Short edge is "+this.shortedge),e==="c"&&x&&!E&&!O&&(this.addNotationMapper="NxNxNCubeMapper",this.setReidOrder=!0),e==="c"&&O&&!x&&!E&&(this.addNotationMapper="SkewbMapper"),e==="t"&&(O||x)&&!E&&(this.addNotationMapper="PyraminxOrTetraminxMapper"),e==="o"&&x&&(this.notationMapper=new zt(this.swizzler,new ht(["F","D","L","BL","R","U","BR","B"])),!E&&!O&&(this.addNotationMapper="FTOMapper")),e==="d"&&x&&(this.addNotationMapper="MegaminxMapper",this.notationMapper=new zt(this.swizzler,new ht(["U","F","L","BL","BR","R","FR","FL","DL","B","DR","D"])))}keyface(t){return this.keyface2(t.centermass())}keyface2(t){let e="";const s=String.fromCharCode;for(const i of this.moveplanesets)if(i.length>0){const n=t.dot(i[0]);let o=0,r=1;for(;r*2<=i.length;)r*=2;for(;r>0;r>>=1)o+r<=i.length&&n>i[o+r-1].a&&(o+=r);if(o<47)e=e+s(33+o);else if(o<47+47*47)e=e+s(33+47+Math.floor(o/47)-1)+s(33+o%47);else if(o<47+47*47+47*47*47)e=e+s(33+47+Math.floor((o-47)/(47*47)-1))+s(33+47+Math.floor((o-47)/47)%47)+s(33+o%47);else throw Error("Too many slices for cubie encoding")}return e}keyface3(t){const e=t.centermass(),s=[];for(const i of this.moveplanesets)if(i.length>0){const n=e.dot(i[0]);let o=0,r=1;for(;r*2<=i.length;)r*=2;for(;r>0;r>>=1)o+r<=i.length&&n>i[o+r-1].a&&(o+=r);s.push(o)}return s}findface(t){const e=this.keyface2(t),s=this.facelisthash.get(e);if(s.length===1)return s[0];for(let i=0;i+1<s.length;i++){const n=this.facelisthash.get(e)[i];if(Math.abs(t.dist(this.facecentermass[n]))<A)return n}return s[s.length-1]}project2d(t,e,s){const i=this.facenames[t][0],n=(e+1)%i.length,o=this.baseplanes[t];let r=i[n].sub(i[e]);const g=r.len();r=r.normalize();const l=r.cross(o).normalize();let f=s[1].sub(s[0]);const v=f.len()/g;f=f.normalize();const a=f.b,m=f.c,u=r.smul(a).sub(l.smul(m)).smul(v),h=l.smul(a).sum(r.smul(m)).smul(v),d=new C(0,s[0].b-u.dot(i[e]),s[0].c-h.dot(i[e]),0);return[u,h,d]}allstickers(){this.faces=pe(this.baseplanerot,this.faces),this.options.verbosity>0&&console.log("# Total stickers is now "+this.faces.length),this.facecentermass=new Array(this.faces.length);for(let p=0;p<this.faces.length;p++)this.facecentermass[p]=this.faces[p].centermass();const t=[],e=[];for(const p of this.moveplanes){const k=p.makenormal();let R=!1;for(const F of e)k.sameplane(F.makenormal())&&(R=!0);R||(e.push(k),t.push([]))}for(const p of this.moveplanes2){const k=p.makenormal();for(let R=0;R<e.length;R++)if(k.sameplane(e[R])){t[R].push(p);break}}for(let p=0;p<t.length;p++){const k=t[p].map(F=>F.normalizeplane()),R=e[p];for(let F=0;F<k.length;F++)k[F].makenormal().dist(R)>A&&(k[F]=k[F].smul(-1));k.sort((F,M)=>F.a-M.a),t[p]=k}this.moveplanesets=t,this.moveplanenormals=e;const s=t.map(p=>p.length);this.options.verbosity>0&&console.log("# Move plane sets: "+s);const i=[];for(let p=0;p<t.length;p++)i.push([]);for(const p of this.rotations){if(Math.abs(Math.abs(p.a)-1)<A)continue;const k=p.makenormal();for(let R=0;R<t.length;R++)if(k.sameplane(e[R])){i[R].push(p);break}}this.moverotations=i;for(let p=0;p<i.length;p++){const k=i[p],R=k[0].makenormal();for(let F=0;F<k.length;F++)R.dist(k[F].makenormal())>A&&(k[F]=k[F].smul(-1));k.sort((F,M)=>F.angle()-M.angle()),i[p][0].dot(e[p])<0&&k.reverse()}const n=i.map(p=>1+p.length);this.movesetorders=n;const o=[];let r="?";for(let p=0;p<t.length;p++){const k=e[p];let R=null,F=null;for(const M of this.geonormals){const y=k.dot(M[0]);Math.abs(y-1)<A?(F=[M[1],M[2]],r=M[2]):Math.abs(y+1)<A&&(R=[M[1],M[2]],r=M[2])}if(F===null||R===null)throw new Error("Saw positive or negative sides as null");o.push([F[0],F[1],R[0],R[1],1+t[p].length]),this.addNotationMapper==="NxNxNCubeMapper"&&r==="f"&&(this.notationMapper=new Qt(1+t[p].length),this.addNotationMapper=""),this.addNotationMapper==="SkewbMapper"&&t[0].length===1&&(this.notationMapper=new Yt(this.swizzler),this.addNotationMapper=""),this.addNotationMapper==="PyraminxOrTetraminxMapper"&&(t[0].length===2&&t[0][0].a===.333333333333333&&t[0][1].a===1.66666666666667?(this.notationMapper=new Pt(this.swizzler),this.addNotationMapper=""):(this.notationMapper=new Zt(this.swizzler),this.addNotationMapper="")),this.addNotationMapper==="MegaminxMapper"&&r==="f"&&(1+t[p].length===3&&(this.notationMapper=new Kt(this.notationMapper)),this.addNotationMapper=""),this.addNotationMapper==="FTOMapper"&&r==="f"&&(1+t[p].length===3&&(this.notationMapper=new $t(this.notationMapper,this.swizzler)),this.addNotationMapper="")}this.movesetgeos=o;const g=new Map,l=this.faces;for(let p=0;p<l.length;p++){const k=l[p],R=this.keyface(k);if(!g.get(R))g.set(R,[p]);else{const F=g.get(R);if(F.push(p),F.length===this.baseFaceCount){this.options.verbosity>0&&console.log("# Splitting core.");for(let M=0;M<F.length;M++){const y=R+" "+M;g.set(y,[F[M]])}}}}this.facelisthash=g,this.options.verbosity>0&&console.log("# Cubies: "+g.size);const f=[],v=[],a=[];for(const p of g.values())if(p.length!==this.baseFaceCount){if(p.length>1){const k=p.map(y=>l[y].centermass()),R=dt(k);for(let y=0;p.length>2;y++){let L=!1;for(let P=0;P<p.length;P++){const U=(P+1)%p.length;if(R.dot(k[P].cross(k[U]))<0){const I=k[P];k[P]=k[U],k[U]=I;const $=p[P];p[P]=p[U],p[U]=$,L=!0}}if(!L)break;if(y>1e3)throw new Error("Bad epsilon math; too close to border")}let F=0,M=p[F];for(let y=1;y<p.length;y++){const L=p[y];this.faceprecedence[this.getfaceindex(L)]<this.faceprecedence[this.getfaceindex(M)]&&(F=y,M=L)}if(F!==0){const y=p.slice();for(let L=0;L<p.length;L++)p[L]=y[(F+L)%p.length]}}for(let k=0;k<p.length;k++){const R=p[k];v[R]=f.length,a[R]=k}f.push(p)}this.cubies=f,this.facetocubie=v,this.facetoord=a;const m=["?","CENTERS","EDGES","CORNERS","C4RNER","C5RNER"],u=[],h=[0,0,0,0,0,0],d=[],w=[];let z=0;const x=[],E=[],O=[],G=[],H=p=>f[p].map(k=>this.getfaceindex(k)).join(" "),N=[];for(let p=0;p<f.length;p++){if(w[p])continue;const k=f[p];if(k.length===0)continue;const R={};let F=0;O.push(0),N.push([]);const M=k.length,y=h[M]++;let L=m[M];(L===void 0||M===this.baseFaceCount)&&(L="CORE"),L=L+(y===0?"":y+1),u[z]=L,d[z]=M;const P=[p];let U=0;for(w[p]=!0;U<P.length;){const I=P[U++],$=H(I);if((k.length>1||R[$]===void 0)&&(R[$]=F++),G[I]=R[$],x[I]=z,N[z].push(I),E[I]=O[z]++,P.length<this.rotations.length){const W=this.facecentermass[f[I][0]];for(const K of i){const V=this.facetocubie[this.findface(W.rotatepoint(K[0]))];w[V]||(P.push(V),w[V]=!0)}}}z++}if(this.setReidOrder&&4<=this.stickersperface&&this.stickersperface<=9){const p=[["UF","UR","UB","UL","DF","DR","DB","DL","FR","FL","BR","BL"],["UFR","URB","UBL","ULF","DRF","DFL","DLB","DBR"],["U","L","F","R","B","D"]],k={};for(const R of p)for(let F=0;F<R.length;F++){let M=0;for(let y=0;y<R[F].length;y++)M|=1<<R[F].charCodeAt(y)-65;k[M]=F}for(const R of N)for(const F of R){let M=0;for(const y of f[F])M|=1<<this.facenames[this.getfaceindex(y)][1].charCodeAt(0)-65;E[F]=k[M]}}if(this.cubiesetnums=x,this.cubieordnums=E,this.cubiesetnames=u,this.cubieords=O,this.orbitoris=d,this.cubievaluemap=G,this.cubiesetcubies=N,this.options.fixedPieceType!==null){for(let p=0;p<f.length;p++)if(this.options.fixedPieceType==="v"&&f[p].length>2||this.options.fixedPieceType==="e"&&f[p].length===2||this.options.fixedPieceType==="f"&&f[p].length===1){this.fixedCubie=p;break}if(this.fixedCubie<0)throw new Error("Could not find a cubie of type "+this.options.fixedPieceType+" to fix.")}this.options.verbosity>0&&console.log("# Cubie orbit sizes "+O)}unswizzle(t){const e=this.notationMapper.notationToInternal(t);return e===null?null:e.modified({family:this.swizzler.unswizzle(e.family)})}stringToBlockMove(t){const e=RegExp("^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$"),s=t.match(e);if(s===null)throw new Error("Bad move passed "+t);const i=s[4];let n,o;if(s[2]!==void 0){if(s[3]===void 0)throw new Error("Missing second number in range");n=parseInt(s[2],10)}s[3]!==void 0&&(o=parseInt(s[3],10));let r="1",g=1;return s[5]!==void 0&&(r=s[5],r[0]==="'"&&(r="-"+r.substring(1)),g=parseInt(r,10)),new j(new T(i,o,n),g)}parseMove(t){const e=this.notationMapper.notationToInternal(t);if(e===null)throw new Error("Bad move "+t.family);t=e;let s=t.family,i=!1;if(s.endsWith("v")&&s[0]<="Z"){if(t.innerLayer!==void 0||t.outerLayer!==void 0)throw new Error("Cannot use a prefix with full cube rotations");s=s.slice(0,-1),i=!0}s.endsWith("w")&&s[0]<="Z"&&(s=s.slice(0,-1).toLowerCase());let n,o=-1;const r=this.swizzler.unswizzle(s);let g=!1;for(let v=0;v<this.movesetgeos.length;v++){const a=this.movesetgeos[v];r===a[0]&&(g=!0,n=a,o=v),r===a[2]&&(g=!1,n=a,o=v)}let l=1,f=1;if(s.toUpperCase()!==s&&(f=2),n===void 0)throw new Error("Bad grip in move "+t.family);if(t.outerLayer!==void 0&&(l=t.outerLayer),t.innerLayer!==void 0&&(t.outerLayer===void 0?(f=t.innerLayer,s<="Z"?l=f:l=1):f=t.innerLayer),l--,f--,i&&(l=0,f=this.moveplanesets[o].length),l<0||l>this.moveplanesets[o].length||f<0||f>this.moveplanesets[o].length)throw new Error("Bad slice spec "+l+" "+f+" vs "+this.moveplanesets[o].length);if(l===0&&f===this.moveplanesets[o].length&&!i)throw new Error("! full puzzle rotations must be specified with v suffix.");return[void 0,o,l,f,g,t.amount]}parsemove(t){const e=this.parseMove(this.stringToBlockMove(t));return e[0]=t,e}genperms(){if(this.cmovesbyslice.length>0)return;const t=[];if(this.options.orientCenters){for(let e=0;e<this.cubies.length;e++)if(this.cubies[e].length===1){const s=this.cubies[e][0],i=this.getfaceindex(s);if(this.basefaces[i].centermass().dist(this.facecentermass[s])<A){const n=this.basefaces[i].length;for(let o=1;o<n;o++)this.cubies[e].push(this.cubies[e][o-1]);this.duplicatedFaces[s]=n,this.duplicatedCubies[e]=n,this.orbitoris[this.cubiesetnums[e]]=n}}}for(let e=0;e<this.moveplanesets.length;e++){const s=this.moveplanesets[e],i=[],n=[s.length+1,0];let o=1;for(;o*2<=s.length;)o*=2;for(let l=0;l<this.faces.length;l++){let f=0;if(s.length>0){const v=this.facecentermass[l].dot(s[0]);for(let a=o;a>0;a>>=1)f+a<=s.length&&v>s[f+a-1].a&&(f+=a);f=s.length-f}for(i.push(f);n.length<=f;)n.push(0);n[f]++}const r=new Array(n.length);for(let l=0;l<n.length;l++)r[l]=[];const g=[];for(let l=0;l<this.faces.length;l++){if(i[l]<0)continue;const f=[this.facetocubie[l],this.facetoord[l]];let v=this.facecentermass[l];const a=v;let m=l;const u=i[m];for(;;){i[m]=-1;const h=v.rotatepoint(this.moverotations[e][0]);if(h.dist(a)<A)break;m=this.findface(h),f.push(this.facetocubie[m],this.facetoord[m]),v=h}if(f.length>2&&this.options.orientCenters&&(this.cubies[f[0]].length===1||this.duplicatedCubies[f[0]]>1)&&this.facecentermass[l].dist(this.basefaces[this.getfaceindex(l)].centermass())<A){let h=this.faces[this.cubies[f[0]][0]];for(let d=0;d<f.length;d+=2){const w=this.faces[this.cubies[f[d]][0]];let z=-1;for(let x=0;x<h.length;x++)if(w.get(x).dist(h.get(0))<A){z=x;break}if(z<0)throw new Error("Couldn't find rotation of center faces; ignoring for now.");f[d+1]=z,h=h.rotate(this.moverotations[e][0])}}if(f.length===2&&this.options.orientCenters)for(let h=1;h<this.movesetorders[e];h++)u===0?f.push(f[0],h):f.push(f[0],(this.movesetorders[e]-h)%this.movesetorders[e]);if(f.length>2&&!g[f[0]]){if(f.length!==2*this.movesetorders[e])throw new Error("Bad length in perm gen");for(const h of f)r[u].push(h)}for(let h=0;h<f.length;h+=2)g[f[h]]=!0}for(let l=0;l<r.length;l++)r[l]=r[l].slice();t.push(r)}if(this.cmovesbyslice=t,this.options.moveList){const e=[];for(const s of this.options.moveList)e.push(this.parsemove(s));this.parsedmovelist=e}this.facelisthash.clear(),this.facecentermass=[]}getboundarygeometry(){return{baseplanes:this.baseplanes,facenames:this.facenames,faceplanes:this.faceplanes,vertexnames:this.vertexnames,edgenames:this.edgenames,geonormals:this.geonormals}}getmovesets(t){const e=this.moveplanesets[t].length;let s=[];if(this.parsedmovelist!==void 0)for(const i of this.parsedmovelist)i[1]===t&&(i[4]?s.push([i[2],i[3]]):s.push([e-i[3],e-i[2]]),s.push(i[5]));else if(this.options.vertexMoves&&!this.options.allMoves){const i=this.movesetgeos[t];if(i[1]!==i[3])for(let n=0;n<e;n++)i[1]!=="v"?(this.options.outerBlockMoves?s.push([n+1,e]):s.push([n+1]),s.push(1)):(this.options.outerBlockMoves?s.push([0,n]):s.push([n,n]),s.push(1))}else for(let i=0;i<=e;i++)!this.options.allMoves&&i+i===e||(this.options.outerBlockMoves?i+i>e?s.push([i,e]):s.push([0,i]):s.push([i,i]),s.push(1));if(this.fixedCubie>=0){const i=this.keyface3(this.faces[this.cubies[this.fixedCubie][0]])[t],n=[];for(let o=0;o<s.length;o+=2){let r=s[o];if(i>=r[0]&&i<=r[1])if(r[0]===0)r=[r[1]+1,e];else if(e===r[1])r=[0,r[0]-1];else throw Error("fixed cubie option would disconnect move");let g=!1;for(let l=0;l<n.length;l+=2)if(n[l][0]===r[0]&&n[l][1]===r[1]&&n[l+1]===s[o+1]){g=!0;break}g||(n.push(r),n.push(s[o+1]))}s=n}return s}graybyori(t){let e=this.cubies[t].length;return this.duplicatedCubies[t]&&(e=1),e===1&&(this.options.grayCenters||!this.options.includeCenterOrbits)||e===2&&(this.options.grayEdges||!this.options.includeEdgeOrbits)||e>2&&(this.options.grayCorners||!this.options.includeCornerOrbits)}skipbyori(t){let e=this.cubies[t].length;return this.duplicatedCubies[t]&&(e=1),e===1&&!this.options.includeCenterOrbits||e===2&&!this.options.includeEdgeOrbits||e>2&&!this.options.includeCornerOrbits}skipcubie(t){return this.skipbyori(t)}header(t){return t+me+`
`+t+`
`}writegap(){const t=this.getOrbitsDef(!1),e=[],s=[];for(let n=0;n<t.moveops.length;n++){let o="M_"+Nt(this.notationMapper,t.movenames[n]),r=!1;o[o.length-1]==="'"&&(o=o.substring(0,o.length-1),r=!0),s.push(o),r?e.push(o+":="+t.moveops[n].toPerm().inv().toGap()+";"):e.push(o+":="+t.moveops[n].toPerm().toGap()+";")}e.push("Gen:=["),e.push(s.join(",")),e.push("];");const i=t.solved.identicalPieces();return e.push("ip:=["+i.map(n=>"["+n.map(o=>o+1).join(",")+"]").join(",")+"];"),e.push("# Size(Group(Gen));"),e.push("# Size(Stabilizer(Group(Gen), ip, OnTuplesSets));"),e.push(""),this.header("# ")+e.join(`
`)}writeksolve(t="PuzzleGeometryPuzzle"){const e=this.getOrbitsDef(!1);return this.header("# ")+e.toKsolve(t,this.notationMapper).join(`
`)}getKPuzzleDefinition(t=!0,e=!0){const i=this.getOrbitsDef(t,e).toKPuzzleDefinition(e);if(i.experimentalPuzzleDescription=this.puzzleDescription,!i)throw new Error("Missing definition!");return i}getMoveFromBits(t,e,s,i,n,o){const r=[],g=[],l=[];for(const a of this.cubieords)g.push(Y(a)),l.push(st(a));for(let a=t[0];a<=t[1];a++){const m=i[a];for(let u=0;u<m.length;u+=2*o){const h=m.slice(u,u+2*o),d=this.cubiesetnums[h[0]];for(let x=0;x<h.length;x+=2)h[x]=this.cubieordnums[h[x]];let w=2,z=3;s&&(w=h.length-2,z=h.length-1),g[d]===Y(this.cubieords[d])&&(g[d]=g[d].slice(),this.orbitoris[d]>1&&!this.options.fixedOrientation&&(l[d]=l[d].slice()));for(let x=0;x<h.length;x+=2)g[d][h[(x+w)%h.length]]=h[x],this.orbitoris[d]>1&&!this.options.fixedOrientation&&(l[d][h[x]]=(h[(x+z)%h.length]-h[(x+1)%h.length]+2*this.orbitoris[d])%this.orbitoris[d])}}let f=new et(Y(24),st(24),1);for(let a=0;a<this.cubiesetnames.length;a++)if(!(n&&!n[a]))if(this.orbitoris[a]===1||this.options.fixedOrientation)g[a]===Y(f.perm.length)?(g[a]!==f.perm&&(f=new et(g[a],l[a],1)),r.push(f)):r.push(new et(g[a],l[a],1));else{const m=new Array(l[a].length);for(let u=0;u<g[a].length;u++)m[u]=l[a][g[a][u]];r.push(new et(g[a],m,this.orbitoris[a]))}let v=new nt(r);return e!==1&&(v=v.mulScalar(e)),v}omitSet(t){for(const e of this.options.excludeOrbits)if(e===t)return!0;return!1}diffmvsets(t,e,s,i){for(let n=0;n<t.length;n+=2){let o=!1;for(let r=0;!o&&r<e.length;r+=2)i?t[n][0]+e[r][1]===s&&t[n][1]+e[r][0]===s&&t[n+1]===e[r+1]&&(o=!0):t[n][0]===e[r][0]&&t[n][1]===e[r][1]&&t[n+1]===e[r+1]&&(o=!0);if(!o)return!0}return!1}getOrbitsDef(t,e=!0){const s=[];if(t)for(let a=0;a<this.cubiesetnames.length;a++)s.push(1);const i=[],n=[],o=[],r=[];for(let a=0;a<this.moveplanesets.length;a++){const m=this.getmovesets(a);o.push(m),this.options.addRotations?r.push(1):r.push(0)}if(this.options.moveList&&this.options.addRotations){for(let a=0;a<this.moverotations.length;a++)r[a]=0;for(let a=0;a<this.moveplanesets.length;a++)for(let m=0;m<this.moverotations.length;m++){let u=this.moveplanenormals[a];for(let h=1;h*2<=this.movesetorders[m];h++){if(u=u.rotatepoint(this.moverotations[m][0]),r[m]&h)continue;let d=-1,w=!1;for(let x=0;x<this.moveplanenormals.length;x++)if(u.dist(this.moveplanenormals[x])<A){d=x;break}else if(u.dist(this.moveplanenormals[x].smul(-1))<A){d=x,w=!0;break}if(d<0)throw new Error("Could not find rotation");const z=o[d];(z.length!==o[a].length||this.moveplanesets[a].length!==this.moveplanesets[d].length||this.diffmvsets(z,o[a],this.moveplanesets[d].length,w))&&(r[m]|=h)}}for(let a=0;a<this.moverotations.length;a++)if(r[a]===0)r[a]=1;else if(r[a]===1)this.movesetorders[a]>3?r[a]=2:r[a]=0;else if(r[a]===3)r[a]=0;else throw new Error("Impossible addrot val")}for(let a=0;a<this.moveplanesets.length;a++)r[a]!==0&&(o[a].push([0,this.moveplanesets[a].length]),o[a].push(r[a]));for(let a=0;a<this.moveplanesets.length;a++){const m=o[a],u=this.movesetorders[a];for(let w=0;w<m.length;w+=2)for(let z=0;z<w;z+=2)if(m[w]===m[z]&&m[w+1]===m[z+1])throw new Error("Redundant moves in moveset.");const h=[];for(let w=0;w<m.length;w+=2)for(let z=m[w][0];z<=m[w][1];z++)h[z]=1;const d=this.cmovesbyslice[a];for(let w=0;w<d.length;w++){if(h[w]!==1)continue;const z=d[w];for(let x=0;x<z.length;x+=2*u){if(this.skipcubie(z[x]))continue;const E=this.cubiesetnums[z[x]];s[E]=1}}}for(let a=0;a<this.cubiesetnames.length;a++)if(s[a]){if(this.omitSet(this.cubiesetnames[a])){s[a]=0;continue}i.push(this.cubiesetnames[a]),n.push(new bt(this.cubieords[a],this.options.fixedOrientation?1:this.orbitoris[a]))}const g=[];for(let a=0;a<this.cubiesetnames.length;a++){if(!s[a]||this.omitSet(this.cubiesetnames[a]))continue;const m=[],u=[];for(let h=0;h<this.cubieords[a];h++){if(t)m.push(h);else{const d=this.cubiesetcubies[a][h];m.push(this.cubievaluemap[d])}u.push(0)}g.push(new et(m,u,this.options.fixedOrientation?1:this.orbitoris[a]))}const l=[],f=[];if(e)for(let a=0;a<this.moveplanesets.length;a++){const u=this.moveplanesets[a].length,h=o[a],d=this.movesetgeos[a];for(let w=0;w<h.length;w+=2){const z=h[w],x=ye(d,z,u),E=x[0],O=x[1];h[w+1]===1?l.push(E):l.push(E+h[w+1]);const G=this.getMoveFromBits(z,h[w+1],O,this.cmovesbyslice[a],s,this.movesetorders[a]);f.push(G)}}let v=new vt(i,n,new yt(g),l,f);return this.options.optimizeOrbits&&(v=v.optimize()),this.options.scrambleAmount!==0&&v.scramble(this.options.scrambleAmount),v}getScramble(t=0){const e=this.getOrbitsDef(!1);return e.transformToKTransformationData(e.getScrambleTransformation(t))}getMovesAsPerms(){return this.getOrbitsDef(!1).moveops.map(t=>t.toPerm())}showcanon(t){ie(this.getOrbitsDef(!1),t)}getsolved(){const t=[];for(let e=0;e<this.baseFaceCount;e++)for(let s=0;s<this.stickersperface;s++)t.push(e);return new X(t)}getOrientationRotation(t){const[e,[s,i,n]]=t[0],o=new C(0,s,-i,n),[r,[g,l,f]]=t[1],v=new C(0,g,-l,f);let a=null,m=null;const u=this.swizzler.unswizzle(e),h=this.swizzler.unswizzle(r);for(const x of this.geonormals)u===x[1]&&(a=x[0]),h===x[1]&&(m=x[0]);if(!a)throw new Error("Could not find feature "+e);if(!m)throw new Error("Could not find feature "+r);const d=a.pointrotation(o);return m.rotatepoint(d).unproject(o).pointrotation(v.unproject(o)).mul(d)}getInitial3DRotation(){const t=this.baseFaceCount;let e=null;if(this.options.puzzleOrientation?e=this.options.puzzleOrientation:this.options.puzzleOrientations&&(e=this.options.puzzleOrientations[t]),e||(e=we()[t]),!e)throw new Error("No default orientation?");return this.getOrientationRotation(e)}generate2dmapping(t=800,e=500,s=10,i=!1,n=.92){t-=2*s,e-=2*s;function o(M,y){let L=M[1][0]-M[0][0],P=M[1][1]-M[0][1];const U=2*Math.PI/y,I=Math.cos(U),$=Math.sin(U);for(let W=2;W<y;W++){const K=L*I+P*$;P=P*I-L*$,L=K,M.push([M[W-1][0]+L,M[W-1][1]+P])}}this.genperms();const l=this.getboundarygeometry().facenames[0][0].length,f=this.net;if(f===null)throw new Error("No net?");const v={};let a=0,m=0,u=1,h=0;v[f[0][0]]=[[1,0],[0,0]],o(v[f[0][0]],l);for(const M of f){const y=M[0];if(!v[y])throw new Error("Bad edge description; first edge not connected.");for(let L=1;L<M.length;L++){const P=M[L];P===""||v[P]||(v[P]=[v[y][L%l],v[y][(L+l-1)%l]],o(v[P],l))}}for(const M in v){const y=v[M];for(const L of y)a=Math.min(a,L[0]),u=Math.max(u,L[0]),m=Math.min(m,L[1]),h=Math.max(h,L[1])}const d=Math.min(t/(u-a),e/(h-m)),w=.5*(t-d*(u+a)),z=.5*(e-d*(h+m)),x={},E=this.getboundarygeometry(),O={},G=[[d+w,z],[w,z]];O[f[0][0]]=G,o(O[f[0][0]],l),x[this.facenames[0][1]]=this.project2d(0,0,[new C(0,G[0][0],G[0][1],0),new C(0,G[1][0],G[1][1],0)]);const H=[];H[0]=0;for(const M of f){const y=M[0];if(!O[y])throw new Error("Bad edge description; first edge not connected.");let L=-1;for(let U=0;U<E.facenames.length;U++)if(y===E.facenames[U][1]){L=U;break}if(L<0)throw new Error("Could not find first face name "+y);const P=E.facenames[L][0];for(let U=1;U<M.length;U++){const I=M[U];if(I===""||O[I])continue;O[I]=[O[y][U%l],O[y][(U+l-1)%l]],o(O[I],l);const $=H[L],W=P[($+U)%l].sum(P[($+U+l-1)%l]).smul(.5),K=ot(E.edgenames,W),V=E.edgenames[K][1],it=xe(V,this.facenames),q=it[y===it[0]?1:0];let _=-1;for(let b=0;b<E.facenames.length;b++)if(q===E.facenames[b][1]){_=b;break}if(_<0)throw new Error("Could not find second face name");const c=E.facenames[_][0];for(let b=0;b<c.length;b++)if(c[b].sum(c[(b+1)%l]).smul(.5).dist(W)<=A){const B=O[y][(U+l-1)%l],S=O[y][U%l];H[_]=b,x[q]=this.project2d(_,b,[new C(0,S[0],S[1],0),new C(0,B[0],B[1],0)]);break}}}let N=0,p=0;const k=this.getInitial3DRotation();for(let M of this.faces){i&&(M=M.rotate(k));for(let y=0;y<M.length;y++)N=Math.max(N,Math.abs(M.get(y).b)),p=Math.max(p,Math.abs(M.get(y).c))}const R=Math.min(e/p/2,(t-s)/N/4);return(M,y)=>{if(i){y=y.rotatepoint(k);const L=.5*s+.25*t,P=this.baseplanes[M].rotateplane(k).d<0?1:-1;return[s+t*.5+P*(L-y.b*R),s+e*.5+y.c*R]}else{const L=x[this.facenames[M][1]];return[s+n*y.dot(L[0])+L[2].b,s+e-n*y.dot(L[1])-L[2].c]}}}generatesvg(t=800,e=500,s=10,i=!1){const n=this.generate2dmapping(t,e,s,i);function o(a,m,u){return'<polygon id="'+a+'" class="sticker" style="fill: '+u+'" points="'+m.map(h=>h[0]+" "+h[1]).join(" ")+`"/>
`}const r=this.getsolved(),g=[],l=[];for(let a=0;a<this.baseFaceCount;a++)g[a]=this.colors[this.facenames[a][1]];for(let a=0;a<this.faces.length;a++){const m=this.faces[a],u=Math.floor(a/this.stickersperface),h=[];for(let d=0;d<m.length;d++)h.push(n(u,m.get(d)));l.push(h)}const f=[];for(let a=0;a<this.baseFaceCount;a++){f.push("<g>"),f.push("<title>"+this.facenames[a][1]+`</title>
`);for(let m=0;m<this.stickersperface;m++){const u=a*this.stickersperface+m,h=this.facetocubie[u],d=this.facetoord[u],w=this.cubiesetnums[h],z=this.cubieordnums[h],x=this.graybyori(h)?"#808080":g[r.p[u]];let E=this.cubiesetnames[w]+"-l"+z+"-o"+d;if(f.push(o(E,l[u],x)),this.duplicatedFaces[u])for(let O=1;O<this.duplicatedFaces[u];O++)E=this.cubiesetnames[w]+"-l"+z+"-o"+O,f.push(o(E,l[u],x))}f.push("</g>")}return`<svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 800 500">
<style type="text/css"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>
`+f.join("")+"</svg>"}get3d(t){const e=[],s=this.getInitial3DRotation(),i=[],n=.52*this.basefaces[0].get(0).len();for(let l=0;l<this.basefaces.length;l++){const f=this.basefaces[l].rotate(s),v=this.facenames[l][1];i.push({coords:gt(f,n),name:v})}for(let l=0;l<this.faces.length;l++){const f=Math.floor(l/this.stickersperface),v=this.facetocubie[l],a=this.facetoord[l],m=this.cubiesetnums[v],u=this.cubieordnums[v];let h=this.graybyori(v)?"#808080":this.colors[this.facenames[f][1]];t!=null&&t.stickerColors&&(h=t.stickerColors[l]);const d=this.faces[l].rotate(s);e.push({coords:gt(d,n),color:h,orbit:this.cubiesetnames[m],ord:u,ori:a,face:f});let w=d;if(this.duplicatedFaces[l]){const z=w.length/this.duplicatedFaces[l];for(let x=1;x<this.duplicatedFaces[l];x++){for(let E=0;E<z;E++)w=w.rotateforward();e.push({coords:gt(w,n),color:h,orbit:this.cubiesetnames[m],ord:u,ori:x,face:f,isDup:!0})}}}const o=[];for(let l=0;l<this.movesetgeos.length;l++){const f=this.movesetgeos[l],v=this.movesetorders[l];for(const a of this.geonormals)f[0]===a[1]&&f[1]===a[2]&&(o.push({coordinates:rt(a[0].rotatepoint(s),1),quantumMove:new j(f[0]),order:v}),o.push({coordinates:rt(a[0].rotatepoint(s).smul(-1),1),quantumMove:new j(f[2]),order:v}))}const r=this.generate2dmapping(2880,2160,0,!1,1),g=function(){const l=s.invrot();return function(f,v){let a=new C(0,v[0]*n,-v[1]*n,v[2]*n);a=a.rotatepoint(l);const m=r(f,a);return m[0]/=2880,m[1]=1-m[1]/2160,m}}().bind(this);return{stickers:e,faces:i,axis:o,unswizzle:this.unswizzle.bind(this),notationMapper:this.notationMapper,textureMapper:{getuv:g}}}getGeoNormal(t){const e=this.getInitial3DRotation(),s=this.swizzler.unswizzle(t);for(const i of this.geonormals)if(s===i[1]){const n=rt(i[0].rotatepoint(e),1);return Math.abs(n[0])<A&&Math.abs(n[2])<A&&(n[0]=0,n[2]=1e-6),n}}getfaceindex(t){const e=this.stickersperface;return Math.floor(t/e)}textForTwizzleExplorer(){return`Faces ${this.baseplanerot.length}
Stickers per face ${this.stickersperface}
Short edge ${this.shortedge}
Cubies ${this.cubies.length}
Edge distance ${this.edgedistance}
Vertex distance ${this.vertexdistance}`}writeSchreierSims(t){const s=this.getOrbitsDef(!1).reassemblySize();t(`Reassembly size is ${s}`);const i=ue(this.getMovesAsPerms(),t),n=s/i;t(`Ratio is ${n}`)}},Re=class{constructor(t,e){this.pg=t,this.orbitNames=e.orbitnames}lookupMove(t){const e=this.pg.parseMove(t);if(this.pg.parsedmovelist){let o=!1;for(const r of this.pg.parsedmovelist)r[1]===e[1]&&r[2]===e[2]&&r[3]===e[3]&&r[4]===e[4]&&(o=!0);if(!o)return null}let s=[e[2],e[3]];if(!e[4]){const o=this.pg.moveplanesets[e[1]].length;s=[o-e[3],o-e[2]]}const i=this.pg.getMoveFromBits(s,e[5],!e[4],this.pg.cmovesbyslice[e[1]],void 0,this.pg.movesetorders[e[1]]);return vt.transformToKTransformationData(this.orbitNames,i)}};export{Re as ExperimentalPGNotation,ze as PuzzleGeometry,C as Quat,Fe as getPG3DNamedPuzzles,Le as getPuzzleDescriptionString,ve as getPuzzleGeometryByDesc,je as getPuzzleGeometryByName,ke as parseOptions,Ut as parsePuzzleDescription,ue as schreierSims};
